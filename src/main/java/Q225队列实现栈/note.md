## 思路:
https://www.geeksforgeeks.org/implement-stack-using-queue/
https://stackoverflow.com/a/688299/6570986

借助两个队列q1, q2来实现栈，支持`push()`, `pop()`, `peek()`, `empty()`操作

### 版本1: efficient push

> 即: push操作的时间复杂度是O(1), pop和peek操作的时间复杂度是O(n)

设有两个队列q1, q2（*事实上， 在pop过程中我们会交换q1和q2的名称*）

- push操作: 直接往`q1`里面`offer`元素, 所以是`O(1)`的时间复杂度

  > push 1, push 2, push3之后：
  >
  > ```
  > q1 (1, 2, 3) q1.size = 3
  > q2 ()
  > ```

- pop操作:

  - 当q1.size > 1时，对q1执行出队，同时将出队元素放入q2
  - 当q1.size = 1时，q1只剩下一个元素（即最后加入栈的元素），直接弹出即可
  - 最后，交换以下q1和q2的名称

> push 1, push 2, push3之后：
>
> ```
> q1 (1, 2, 3) q1.size = 3
> q2 ()
> ```
>
> 现在我们想pop()，也就是想办法把3弹出来。当`size > 1`时，对q1执行出队，同时将出队元素入队q2：
>
> ```
> q1 (2, 3) q1.size = 2
> q2 (1)
> ```
>
> ```
> q1 (3) q1.size = 1
> q2 (1, 2)
> ```
>
> 此时`size = 1`，q1中剩下唯一一个元素，是我们最后放入“栈”的元素，此时对`q1`执行出队操作并返回值即可。完成之后，交换一下q1和q2的名称，我们始终往`q1`里面`push`元素：
>
> ```
> Queue tmp = q1;
> q1 = q2;
> q2 = tmp;
> ```



### 版本2: efficienct pop

> 即: pop操作的时间复杂度是O(1), push操作的时间复杂度是O(n)



假设我们有两个队列q1, q2

- pop操作

<u>*要想让pop操作的时间复杂度是O(1)，队列应该满足什么条件呢？*</u>

显然，一个队列应该按入栈顺序的逆序存放元素。例如，如果入栈顺序是1,2,3，那么一个队列中的元素应该是`3,2,1`，这样`pop()`直接对该队列执行`poll()`即可。

- push操作

始终往空的队列`q1`中push元素，每次push完，`q1`中仅有一个元素，然后将另一个队列`q2`中的元素全部出队并入队`q1`。此时`q2`变空了，交换`q1`和`q2`的名称。

> 可以结合下面的例子理解：
>
> ```
> push 1: q1 (1)  q2 () --> q1(1) q2()
> swap q1, q2: q1() q2(1)
>
> push 2: q1(2) q2(1) --> q1(2, 1) q2()
> swap q1, q2: q1() q2(2,1)
>
> ```
>
>